//---------------------------------------------------------------------------//
//---PROJET_THEATRE_DMX------------------------------------------------------//
//---Développé par Arthur Dherbomez------------------------------------------//
//---BTSSN2------------------------------------------------------------------//
//---Class:Manager.h---------------------------------------------------------//
//---Cette classe permet de generer un objet de type scene ou programme en lien
//--------------avec la BDD--------------------------------------------------//
//---------------------------------------------------------------------------//

#pragma hdrstop

#include "./Manager/Manager.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

//constructeur
	manager::manager()
	{
		this->mysql = new MySQL();
	}


	void manager::afficheDoubleVector(std::vector<std::vector<std::string> > vector)
	{
		std::string str;

		char * conv = new char[10];
		itoa(vector.size(), conv, 10);

		str += conv;
        str += " lignes\n";

		for (int i = 0; i < vector.size(); i++) {
			for (int j = 0; j < vector[i].size(); j++) {
				str += " " + vector[i][j];
			}

			str += "\n";
		}

		MessageBox(NULL, str.c_str(), "test", MB_OK | MB_ICONQUESTION);
    }

//permet de récupérer un programme dans la bdd grace à son id
	programme*manager::getProg(idProg)
	{
		char *buffer;
		buffer = new char[100];
		this->prog = new programme();
		std::string request = "SELECT * FROM `program` WHERE `idProgram`='";
		itoa(idProg,buffer,10);
		request +=buffer;
		request += "';";
		// On va rechercher en base les informations du programme
		// select Nom from Programme
		//mettre les infos de la base dans la variable nom


		vector < vector < string > > results = this->mysql->Select(request);

			afficheDoubleVector(results);

		this->prog->setId(idProg);
		this->prog->setName(results[0][1]);
		//Je vais en base chercher les scène du programme N°  idProg
		//  SELECT * FROM `scene`,`compoprogram`,`program` WHERE  `scene`.`Id`=`compoprogram`.`IdScene` AND `compoprogram`.`IdProgram` = `program`.`IdProgram` AND `compoprogram`.`IdProgram`='1' order by `compoprogram`.`Place`
		//mettre les infos des scenes de la base dans des variable
		request.clear();
		request = "SELECT * FROM `scene`,`compoprogram`,`program` WHERE  `scene`.`IdScene`=`compoprogram`.`IdScene` AND `compoprogram`.`IdProgram` = `program`.`IdProgram` AND `compoprogram`.`IdProgram`='";
		request +=buffer;
		request += "';";

		vector < vector < string > > results2 = this->mysql->Select(request);

		afficheDoubleVector(results2);

		//récupérer le nombre de ligne ou faire un while
		int NbRow = results2.size();
		this->prog->setNbScene(NbRow);
		//je simule les valeurs de la base
//			for (int i = 0; i < results2.size(); i++) {
//
//			for (int j = 0; j < results2[i].size(); j++) {
//				MessageBox(NULL, results2[i][j].c_str(),"test", MB_OK | MB_ICONQUESTION);
//			}
//		}


		for (int i = 0; i < NbRow; i++)
		{
				scene *s = new scene();
				int StockId=atoi(results2[i][0].c_str());

				s->setId(StockId);
				s->setName(results2[i][1]);
				s->setTime(atoi(results2[i][5].c_str()));

				request.clear();
				request =  "SELECT * FROM `scene`,`sequence` WHERE `sequence`.`IdScene`=`scene`.`IdScene` AND `scene`.`IdScene` = '";
				request += results2[i][0];
				request += "';";
				vector < vector < string > > results3 = this->mysql->Select(request);
				s->setNbSeq(results3.size());

				this->prog->AjouterUneSceneAuProgramme(s);
				delete s;
		}
		return this->prog;
	}
//permet de récupérer une scène dans la bdd grace à son id
	scene*manager::getScn(idScn)
	{
		char *buffer;
		buffer = new char[100];
		this->scn = new scene();
		std::string request = "SELECT * FROM `scene` WHERE `IdScene`='";
		itoa(idScn,buffer,10);
		request +=buffer;
		request += "';";

		vector < vector < string > > results = this->mysql->Select(request);

		afficheDoubleVector(results);
		this->scn->setId(idScn);
		this->scn->setName(results[0][1]);
		request.clear();


	}
	void manager::InsertEquipment(std::string Name, std::map<std::string,property*>properties)
	{
    vector< vector<string> > test;
		char *buffer;
		buffer = new char[100];
		std::string result;
		int idEquipement=0;
		std::string request = "INSERT INTO `equipment`(`Nom`) VALUES ('";
		request += Name;
		request += "');";
		this->mysql->Insert(request);
		request.clear();

		request = "SELECT `IdEquipment` FROM `equipment` WHERE `equipment`.`Nom`='";
		request += Name;
		request += "';";

		test = this->mysql->Select(request);

		idEquipement = atoi(test[0][0].c_str());
		 const char *cstr = Name.c_str();
         char * bite =cstr;
		equipement *e = new equipement(idEquipement,bite);
	}



//permet de vérifier et de remplacer les bons éléments d'une scene dans la bdd
	scene*manager::updateScene(scene*scn)
	{

	}
//permet de vérifier et de remplacer les bons éléments d'un programme dans la bdd
	programme*manager::updateProg(programme*prog)
	{

	}
//permet de renvoyer un message d'envoi réussi
	char*manager::sendOk()
	{

	}
//permet de renvoyer un message d'erreur
	char*manager::sendError()
	{

	}

	bool manager::CheckEtat()
	{
		return this->EtatConnect;
	}

	bool manager::Connect()
	{
		std::string Adresse="192.168.65.97";
		std::string ID="root";
		std::string MDP="root";
		std::string NomDeBase="theater";
		this->EtatConnect=this->mysql->Connect(Adresse,ID,MDP,NomDeBase);
	}

	manager::~manager()
	{
		this->mysql->Disconnect();
	}
