//---------------------------------------------------------------------------//
//---PROJET_THEATRE_DMX------------------------------------------------------//
//---Développé par Arthur Dherbomez------------------------------------------//
//---BTSSN2------------------------------------------------------------------//
//---Class:Manager.h---------------------------------------------------------//
//---Cette classe permet de generer un objet de type scene ou programme en lien
//--------------avec la BDD--------------------------------------------------//
//---------------------------------------------------------------------------//

#pragma hdrstop

#include "Manager.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

//constructeur
	manager::manager()
	{
		this->mysql = new MySQL();
	}


	void manager::afficheDoubleVector(std::vector<std::vector<std::string> > vector)
	{
		for (int i = 0; i < vector.size(); i++) {
			std::string str;

			for (int j = 0; j < vector[i].size(); j++) {
				str += " " + vector[i][j];
			}

			str += "\n";
		}

		MessageBox(NULL, str.c_str(), "test", MB_OK | MB_ICONQUESTION);
    }

//permet de récupérer un programme dans la bdd grace à son id
	programme*manager::getProg(idProg)
	{
		char *buffer;
		buffer = new char[100];
		this->prog = new programme();
		std::string request = "SELECT * FROM `program` WHERE `idProgram`='";
		itoa(idProg,buffer,10);
		request +=buffer;
		request += "';";
		// On va rechercher en base les informations du programme
		// select Nom from Programme
		//mettre les infos de la base dans la variable nom


		vector < vector < string > > results = this->mysql->Select(request);



		this->prog->setId(idProg);
		this->prog->setName(results[1][1]) ;
		//Je vais en base chercher les scène du programme N°  idProg
		//  SELECT * FROM `scene`,`compoprogram`,`program` WHERE  `scene`.`Id`=`compoprogram`.`IdScene` AND `compoprogram`.`IdProgram` = `program`.`IdProgram` AND `compoprogram`.`IdProgram`='1' order by `compoprogram`.`Place`
		//mettre les infos des scenes de la base dans des variable
		request.clear();
		request = "SELECT * FROM `scene`,`compoprogram`,`program` WHERE  `scene`.`Id`=`compoprogram`.`IdScene` AND `compoprogram`.`IdProgram` = `program`.`IdProgram` AND `compoprogram`.`IdProgram`='";
		request +=buffer;
		request += "';";

		vector < vector < string > > results2 = this->mysql->Select(request);

		afficheDoubleVector(results2);

		//récupérer le nombre de ligne ou faire un while
		int NbRow = results2.size();
		//je simule les valeurs de la base
//			for (int i = 0; i < results2.size(); i++) {
//
//			for (int j = 0; j < results2[i].size(); j++) {
//				MessageBox(NULL, results2[i][j].c_str(),"test", MB_OK | MB_ICONQUESTION);
//			}
//		}


		for (int i = 0; i < NbRow; i++)
		{
				scene *s = new scene();
				   std::string *test;
                   test = new std::string();
				   test =&results2[i][1];
//				   int value = atoi(test->c_str());



//				s->setId(value);
//				s->setName(results2[i][1]);
//				s->setTime(atoi(results2[i][5].c_str()));

				request.clear();
				request =  "SELECT * FROM `scene`,`sequence` WHERE `sequence`.`IdScene`=`scene`.`Id` AND `scene`.`Id` = '";
				request += results2[i][0];
				request += "';";
				vector < vector < string > > results3 = this->mysql->Select(request);
				s->setNbSeq(results3.size());

				this->prog->AjouterUneSceneAuProgramme(s);
				delete s;
		}
		return this->prog;
	}
//permet de récupérer une scène dans la bdd grace à son id
	scene*manager::getScn(idScn)
	{
	//scene *S1 = new scene();

	}
//permet de vérifier et de remplacer les bons éléments d'une scene dans la bdd
	scene*manager::updateScene(scene*scn)
	{

	}
//permet de vérifier et de remplacer les bons éléments d'un programme dans la bdd
	programme*manager::updateProg(programme*prog)
	{

	}
//permet de renvoyer un message d'envoi réussi
	char*manager::sendOk()
	{

	}
//permet de renvoyer un message d'erreur
	char*manager::sendError()
	{

	}

	bool manager::CheckEtat()
	{
		return this->EtatConnect;
	}

	void manager::Connect()
	{
		std::string Adresse="192.168.65.97";
		std::string ID="root";
		std::string MDP="root";
		std::string NomDeBase="theater";
		this->EtatConnect=this->mysql->Connect(Adresse,ID,MDP,NomDeBase);
	}

	manager::~manager()
	{
		this->mysql->Disconnect();
	}
