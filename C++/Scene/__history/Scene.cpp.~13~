//---------------------------------------------------------------------------//
//---PROJET_THEATRE_DMX------------------------------------------------------//
//---Développé par Arthur Dherbomez------------------------------------------//
//---BTSSN2------------------------------------------------------------------//
//---Class:Scene.h-----------------------------------------------------------//
//---Cette classe permet de répertorier une scène qui possède plusieurs séquences---//
//---------------------------------------------------------------------------//

#pragma hdrstop

#include "Scene.h"
#include <Windows.h>
//---------------------------------------------------------------------------
#pragma package(smart_init)

//constructeur
	scene::scene(int id, std::string name, int tpsPause)
	{
		this->id=id;
		this->name=name;
		this->tpsPause=tpsPause;
	}
//setID
	void scene::setId(int id)
	{
		this->id=id;
	}
//initialisation du nom
	void scene::setName(std::string name)
	{
		this->name=name;
	}
//initialisation du temps de pause
	void scene::setTime(int tpsPause)
	{
		this->tpsPause=tpsPause;
	}
//initialisation du nombre de séquences d'une scène
	void scene::setNbSeq(std::vector<sequence*>seq)
	{
		this->seq=seq;
	}
//récupération de l'id scene
	int scene::getId()
	{
		return id;
	}
//récupération du Nom de la scène
	std::string scene::getName()
	{
		return name;
	}
//récupération du temps entre chaque scène
	int scene::getTime()
	{
		return tpsPause;
	}
//récupération du nombre de séquences
	int scene::getNbSeq()
	{
		return seq.size();
	}
//initialisation des sequences des scènes
	void scene::setSequences(sequence*sequ)
	{
		this->seq.push_back(sequ);
	}
//récupération des sequences des scènes
	std::vector<sequence*> scene::getSequences()
	{
		return this->seq;
	}

	void scene::planifyScene()
	{   int i;
		unsigned long lastProcessedTime = GetTickCount();
		for (i = 0; i < seq.size(); i++)
		{
			lastProcessedTime+=seq[i]->getDuree();
			times.push_back(lastProcessedTime);
		}

		sequenceIndex = 0;
	}
	bool scene::updateScene()
	{
		unsigned long currentTime= GetTickCount();
		if (currentTime> times[sequenceIndex])
		{
			sequenceIndex++;
			// TODO : Mettre à jour le trameManager avec les sequenceUsedEquipment
			sequence * s = seq[sequenceIndex];
			std::vector<usedEquipement*> usedEquips = s->getTrame()->getUsedEquipement();
			std::vector<sequenceUsedEquipement*> seqUsedEquips = s->getSequenceUsedEquipments();


		}
		return sequenceIndex==seq.size();
	}

	int scene::getSeqIndex()
	{
		return sequenceIndex;
	}
