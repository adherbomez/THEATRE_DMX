//---------------------------------------------------------------------------//
//---PROJET_THEATRE_DMX------------------------------------------------------//
//---Développé par Arthur Dherbomez------------------------------------------//
//---BTSSN2------------------------------------------------------------------//
//---Class:TrameManager.h--------------------------------------------------------//
//---Cette classe permet la construction de la trame DMX en récupérant le canal,
//les équipements et leurs propriétés---//
//---------------------------------------------------------------------------//
#pragma hdrstop

#include "TrameManager.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

//constructeur
	trameManager::trameManager()
	{
		 for (int i = 0; i < 512; i++)
		 {
			 this->dmx[i]=0;
		 }
	}
//insere dans dmx[512] l'equipement à  l'adresse choisi
	bool trameManager::insertEquipement(usedEquipement*usedEquip)
	{
        trame.push_back(usedEquip);
	}
//suppression d'un équipement au canal choisis
	void trameManager::removeEquipement(int adresse,usedEquipement*usedEquip)
	{
		int i,j;

		adresse-=1;

		for (i = 0; i < 512; i++)
		{
			if(dmx[i]==dmx[adresse])
			{
				for (j = adresse; j < adresse+usedEquip->getNbVoies(); j++)
				{
						dmx[j]=NULL;
				}

			}

		}
	}
//verifie si des trames ne se superposes pas et si il n'y a pas d'erreurs
	bool trameManager::checkConflict()
	{
		int i,j;
		graph= new Graph();

		for (i = 0; i < graph->nodes.size() ; i++)
		{
			for (j = i+1; j < graph->nodes.size() ; j++)
			{
				if (Node::localCheckIntersection(graph->nodes[i],graph->nodes[j]))
				{
					graph->conflicts.push_back(new Conflict(graph->nodes[i],graph->nodes[j]));
					return graph->conflicts.size()>0;
				}
			}
		}
		return true;
	}
//récupère la trame
	char* trameManager::getTrame()
	{
		int i,j;

		//adresse-=1;

		for (i = 0; i < 512; i++)
		{
			if(i == usedEquip->getAdresse())
			{
				std::map<usedEquip->getValues();
				for (j = adresse; j < adresse+usedEquip->equip->getNbVoies() ; j++)
				{
						dmx[j]=usedEquip->getValues()[j];
				}
				return true;
			}
			else
			{
				return false;
			}

		}

		return dmx;
	}
//renvoi un vecteur avec toutes les informations utilent à la trame
	std::vector<usedEquipement*> trameManager::getUsedEquipement()
	{
		return trame;
	}
